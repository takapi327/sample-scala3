# 第1章. 効果：評価と実行

私たちは、コードの動作について話すときに、「その操作の効果は何ですか」とか、デバッグのときに「それをやっても効果がないはずですが、どうなっているのですか」というように、効果という言葉をよく使いますが、ここで「どうなっているのですか」はほとんどの場合、罵倒語に置き換えられています。しかし、効果とは何でしょうか？私たちがより理解しやすい、より良いプログラムを書くために、効果について正確な方法で話すことはできるのでしょうか？
効果とは何か、そしてそれをどのように利用できるかを探るために、コードの2つの側面、すなわち値の計算と環境との相互作用を区別して考えます。同時に、これらの側面を記述する際に、コードがどれだけ透明であるか、あるいは透明でないか、そしてプログラマーとして何ができるかを説明します。

## 1.1. 評価の代替モデル

まず、最初の側面である値の計算から見ていこう。プログラマーとして私たちはあるコード、例えばメソッドを書き、そのメソッドが値を計算し、そのメソッドの呼び出し元に返されます。

```scala
def plusOne(i: Int): Int = i+1
val x = plusOne(plusOne(12))
```

このコードについて、いくつか紹介します。

1. plusOneはInt型の引数をとり、Int型の値を生成するメソッドです。plusOneはInt ⇒ Intという型シグネチャを持ち、「IntからIntへ」「plusOneはIntからIntへの関数」と発音される
2. xは値である。plusOne(plusOne(12)) という式を評価した結果として定義されます。

このコードを評価するために代入を使ってみよう。plusOne(plusOne(12)) という式から始めて，それぞれの（部分）式をその定義で代入し，部分式がなくなるまで再帰的に繰り返す．

1. 内側のplusOne(12)をその定義に置き換えてください。

```scala
- val x = plusOne(plusOne(12))
+ val x = plusOne(12 + 1)
```

2. 12 + 1 を 13 に置き換える

```scala
- val x = plusOne(12 + 1))
+ val x = plusOne(13)
```

3. plusOne(13) をその定義に置き換えてください

```scala
- val x = plusOne(13)
+ val x = 13 + 1
```

4. 13 + 1 を 14 に置き換える

```scala
- val x = 13 + 1
+ val x = 14
```

この例では、いくつかの特殊な性質に注目することが重要である。

1. plusOneが何をするのか理解するために、plusOneの（文字通りの）定義以外の場所を見る必要はありません。その外には何も参照するものがないのです。これは局所推論と呼ばれることもあります。
2. 代入では，プログラムが同じ値に評価されれば，同じことを意味します．13 + 1 は 14 と全く同じ意味です。plusOne(12 + 1)もそうだし、(12 + 1) + 1もそうである。これは参照透過と呼ばれる。

関数型プログラミングの入門コースで教えていたときの私の言葉を引用すると、「[代入]はとても愚かなことで、コンピュータでもできる！」です。すべてのプログラムがplusOneのように自己完結していて、私たち人間が代入を使ってコードを評価し、コンピュータと同じ値を出すことができたら、それは素晴らしいことだと思います。

しかし、代入は実際の評価がどのように行われるかのモデルに過ぎない。あらゆる種類の式を扱えるわけではありません。代入が破綻するのはどのような場合でしょうか？いくつかの例を思いつくことができますか？

思い当たるものをいくつかご紹介します。

1. コンソールに印刷する場合 println関数は、コンソールに文字列を印字する関数で、戻り値はUnit型です。代入をかけると

```scala
- val x = println("Hello world!")
+ val x = ()
```

最初の表現と2番目の表現の意味-効果-は非常に異なっている。後者では何も印刷されません。代入を使っても、私たちの意図した通りにはならないのです。

2. 外界から値を読み取る場合。代入を適用すると

```scala
- val name = readLine
+ val name = <whatever you typed in the console>
```

これはコンソールから読み込まれた特定の文字列として評価されますが、その特定の文字列は式 readLine の評価と同じではありません。readLine式は他のものに評価される可能性があります。

3. 式がミュータブル変数を参照する場合

ミュータブルな変数を扱う場合、式の値はその変数に対するあらゆる可能な変更に依存します。次の例では、もし何らかのコードがiの値を変更したら、それはxの評価も変更することになります。

```scala
var i = 12


- val x = { i += 1; i }
+ val x = 13
```

この例は、前の例と非常によく似ています。コンソールにタイプすることは、readLineが返す内容を持つミュータブル変数に書き込むことと考えることができます。

## 1.2. 副作用への対応

効果の第二の側面は、値の計算の後に、環境との相互作用があることです。そして、これまで見てきたように、これによって置換が壊れることがある。環境は変化する可能性があり、非決定的であるため、環境を含む式は必ずしも同じ値で評価されるとは限りません。ミュータブルな状態を使用する場合、隠れた副作用を実行する場合、つまり代入を中断する場合、すべてが失われるのでしょうか？そうではない。

コードに関する推論能力を維持する方法の1つは、置換を破る「不純な」コードをローカライズすることである。外から見ると、コードは置換が行われているように見え、評価されます。しかし、境界の内側には、ドラゴンがいる。

```scala
 def sum(ints: List[Int]): Int = { var sum = 0 // 1
ints.foreach(i => sum += i) sum
}
sum(List(1, 2, 3)) // 2
```

1. ミュータブル変数を使用してしまった。恐るべし! しかし、sumの外部からは何も影響を受けることはありません。その存在は1回の呼び出しに限定されます。
2. sumを使った式を評価すると、決定論的な答えが得られます。このレベルでは代入が効く。

リストの合計を計算するコードを最適化したため、リストに対して不変のフォールドを使用する代わりに、ローカル変数を更新しています。呼び出し側から見ると、代入は維持されている。不純なコードでは、代入がもたらす推論を利用できないので、コードの振る舞いを自分自身で証明するには、この本の範囲外である他のテクニックを使用する必要があります。

ローカライゼーションは良いトリックですが、代入を破るもの全てに有効なわけではありません。私たちはプログラムの中で実際に何かをするために副作用を必要としますが、副作用は安全ではありません! でも副作用は安全ではありません！どうしたらいいのでしょうか？

## 1.3. Effectパターン

いくつかの条件を課すことで、副作用をより安全なものに手なずけることができます。これをエフェクトと呼ぶことにします。次の2つの部分があります。

1. プログラムの型は、それが生成する値の型に加えて、そのプログラムがどのような効果を発揮するのかを教えてくれるはずです。不純なコードの問題点は、それが不純であることが分からないことです! 外から見ると、メソッドやコードのブロックのように見えます。効果に型を与えることで、他のコードと区別することができます。同時に、計算結果の型を追跡し続けることができます。
2. 欲しい動作が外から見える副作用に依存している場合、欲しい効果を記述することと、実際にそれを実現することを分けて考える。実行するまでの記述については、自由に置き換えることができる。この考え方はローカライズの考え方と全く同じですが、コードの最内層で副作用を実行し外層から隠す代わりに、副作用を遅延させて評価の外側で実行し、内部で置換が成立するようにする点が異なります。このような条件を「効果パターン」と呼び、私たちが日常的に使っている効果や、新しい種類の効果の研究・記述に応用していきます。

#### Effect Pattern Checklist
1. プログラムのタイプは私たちに教えてくれますか？
   1. プログラムがどのような効果をもたらすか
   2. プログラムがどのような価値を生み出すか
2. 外部に見える副作用が必要な場合、効果の記述は実行と分離されているか？

どのような効果が考えられますか？それらは両方のルールを満たしていますか？なぜそう思うのですか？

ここでは、よく使われる2つのタイプ、OptionとFutureをEffect Patternの基準で分析してみましょう。これらは効果か？副作用はあるか、そして安全に管理されているか？

### 1.3.1. 例 Optionは効果か？

Scalaを含む多くの言語では、値がないことを意味するnull値の使用を許可しています。プログラマー（あなた！）は、値がNULLかどうかをチェックする必要があります。そうしないと、恐ろしいNullPointerExceptionが実行時にスローされます。

```scala
def isValid(filename: String) =
  filename.length > 0 && filename.startsWith("/") // NullPointerExceptionが多発するので注意。
isValid(null)
```

どのような場合であるかを確認し忘れることを防ぐために、Scalaはオプション性をエンコードする別の方法として、代数的なデータ型を提供しています。

```scala
sealed trait Option[+A]
case class Some[A](value: A) extends Option[A]
case object None extends Option[Nothing]
```

Option[A]は効果あるのか？基準を確認しよう

Q1. Option[A]は、プログラムが生み出す価値の種類だけでなく、どのような効果をもたらすかを教えてくれるのでしょうか？
A1. はい：もしOption[A]という型の値があれば、Optionという名前からその効果がオプションであることがわかりますし、型パラメータAから型Aの値を生成する可能性があることもわかっています。

Q2. 外から見える副作用は必要ですか？
A2. そうではありません。Optionデータ型は、置換を維持するオプション性を表すインタフェースである。メソッドコールをその実装に置き換えても、プログラムの意味は変わらない。ただし、例外的に、外から見える副作用が発生する可能性があります。

```scala
def get(): A = 
  this match {
    case Some(a) => a
    case None => throw new NoSuchElementException("None.get")
  }
```

None で get を呼び出すとプログラマのエラーとなり、例外が発生し、その結果スタックトレースが表示されるかもしれません。しかし、この副作用は例外の概念の核心ではなく、デフォルトの例外ハンドラの実装に過ぎない。例外の本質は非局所的な制御フローであり、動的スコープにある例外ハンドラへのジャンプであり、外部からは見えない副作用である。

この2つの条件を満たせば、Option[A]は「はい、効果です！」と言うことができます。

Optionは副作用を実行しないので、エフェクトと呼ぶのは奇妙に思えるかもしれません。Effectパターンの最初の条件のポイントは、型が効果の存在を可視化することである。Optionの伝統的な代替案としては、null値を使うことが考えられるが、それでは型Aの値がnullかどうかどうやって判断するのだろうか？null 値を持ちうるいくつかの型は、値がないという概念を持つことを意図していない。Option はこの区別を明らかにする。

####  Effect Pattern Checklist: Option[A]の場合

1. プログラムの種類でわかるのか
  1. どのような効果をもたらすのか、そして
    ```Option型は任意性を表す。 オプション性とは、ある値が存在するかもしれない（しないかもしれない）ことを意味する。```
  2. どのような価値を生み出すのか？
    ```A タイプの値が存在する場合、その値。```
2. 外部から見える副作用が必要な場合、その効果の記述は実行と分離されているか？ 実行とは別のものか？
   ```外から見える副作用は必要ありません。```

したがって、Optionは効果である。

### 1.3.2. 例: Futureは効果か？

Futureには、簡単には見えない問題があることが知られています。例えば、次のコードを見てください。同じFutureを参照して、2回実行しています。

```scala
val print = Future(println("Hello World!"))
val twice = print.flatMap(_ => print)
```

どのような出力が出るのか？

```shell
Hello World!
```

印刷されるのは1回だけ! なぜでしょう？

その理由は、Futureは構築されるとすぐに実行されるようにスケジュールされているからです。そのため、他の「記述的」な操作（flatMapの後続の印刷）が後で起こったとしても、副作用は（ほとんど）すぐに起こります。つまり、printを2回実行することを記述していますが、副作用は1回しか実行されないのです!

この実装にprintの定義を代入するとどうなるか、比べてみてください。

1. Replace the first reference to print with its definition
```scala
val print = Future(println("Hello World!"))
val twice = Future(println("Hello World!")).flatMap(_ => print)
```

2. 2番目のprintへの参照をその定義に置き換え、printの定義を削除します。
```scala
val twice = Future(println("Hello World!"))
  .flatMap(_ => Future(println("Hello World!")))
```

それを実行することで、私たちは見ることができます。

```shell
Hello World!
Hello World!
```

これが、Future is not an effectと言う理由です。表現をその定義に置き換えることは、同じ意味を持ちません。

####  Effect Pattern Checklist: Future[A]の場合

1. プログラムの種類でわかるのか
1. どのような効果をもたらすのか、そして
   ```Futureは非同期の計算を表します。```
2. どのような価値を生み出すのか？
   ```非同期計算が成功した場合、タイプAの値を返す。```
2. 外部から見える副作用が必要な場合、その効果の記述は実行と分離されているか？ 実行とは別のものか？
   ```外から見える副作用が必要：Future本体は副作用も含めて何でもできる。しかし、それらの副作用は、構成された操作の記述の後に実行されるのではなく、構築時に直ちに実行がスケジューリングされる。```

したがって、Futureは効果記述と実行を分離しないので、安全ではありません。

![future_is_unsafe.png](./images/future_is_unsafe.png)
