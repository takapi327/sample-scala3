# Cats Effect IOに関して

[メモ]
Future/IOの違い -> 非同期/同期の話 -> そもそもスレッドって何？ -> スレッドにも種類がある -> Javaはどんなスレッド？ -> なぜJavaはネイティブスレッド？
-> Scalaで使ってるFutureは？ -> 普段使ってるExecutionContextって？ -> じゃあIOは何が違う？ -> まずEffectパターンとは? -> 実行遅らせる？実行するときは？
-> IORuntimeって？ -> IOって結局どんなもの？ -> 各スレッドのパフォーマンスは？ -> まとめ

## 目次
- Future/IO違い
- 非同期/同期
- スレッドとは
- スレッドの種類
  - ネイティブスレッド
  - グリーンスレッド
- Javaのスレッド
- JVMはOSのスレッドを使用
- Futureパターン
  - ExecutionContextとは
- IO
  - Effectパターン
  - IORuntimeとは
- Future/IOのパフォーマンス
- まとめ

## Future/IO違い

[メモ]

|      | Future | IO  |
|------|--------|-----|
| 評価   | 逐次     | 遅延  |
| 実行   | ExecutionContextが必要 | IORuntimeが必要 |

### Futureの特徴
[メモ]
- 言語の標準ライブラリとして提供されている
  - 利用者が多い
  - 対応しているライブラリが多い
  - 処理をExecutionContextの実行戦略に従って非同期化する
  - 処理を即時実行する
    - Futureは作成と同時に、対応する処理を否応なしに実行してしまいます
    - 作成に副作用を伴います
  - Futureは作成時に実行される処理の結果をメモ化し、再利用された場合も結果が変わらない
  - 作成にExecutionContextを暗黙に要求
    - 使い回すには少し不便

### IOの特徴
[メモ]
- 参照透過
  - 式を評価値で置き換えても挙動に変更がない性質
- 実行するものを作るというよりも、いつか起こす作用の設計図を作るイメージ
- 実行がend-of-the-world
- Fiberと呼ばれるグリーンスレッドを使用
- 遅延評価つきFuture

[疑問]
- グリーンスレッドは軽量と言われているが、ネイティブスレッドは1つ1つのスレッドが重いの？
  - コンテキストスイッチは重いらしい
- グリーンスレッド(ユーザー空間)は、ネイティブスレッド(OS)と別の場所でネイティブスレッドはOSのスレッドを使用グリーンスレッドは、アプリケーション用に確保したメモリを使用
  - アプリケーションを構築する環境(例えばAWSのECSなど)のメモリがMAX100メガだった場合に、ネイティブスレッドでフルを使う場合とネイティブスレッド20メガ、グリーンスレッド80メガだったら後者の方がスレッド生成は多くなる
    - ネイティブスレッド : グリーンスレッドは n : m の関係でn1に対してmは10にも100にもなる？
    - グリーンスレッドの方が良さそうに聞こえるが、ネイティブスレッドのメリットは？I/O？
    - どんなアプリケーションを構築する場合に、ネイティブスレッドよりグリーンスレッドを使う方がよくなる？
      - 昨今のアプリケーションの求められるものは、アクセス過多(通信リクエストを複数同時にさばくこと)にも耐えうる性能？
      - グリーンスレッドだとECSなどのパフォーマンスをあげなくても対応できる？

## スレッドとは
[メモ]
- CPU利用の単位
- ある処理を単一のスレッドのみを用いて動作させる環境もしくは手法をシングルスレッドという。対して、複数のスレッドが同時に動作することをマルチスレッドという。
- プログラム（概ねプロセス）の開始時にはメインとなるスレッドが動作する。必要に応じてその他の処理をするスレッドを作り、実行させる事も出来る。

## ネイティブスレッド
## グリーンスレッド

[メモ]
- OSではなく仮想マシンやランタイムライブラリによってスケジュールされるスレッド。グリーンスレッドは、OSの機能によらずにマルチスレッド環境をエミュレートする。
- OSではなくアプリケーションレベルで実装されるスレッド
- カーネルのスレッドに関するサポートが受けられない環境上で、マルチスレッドを実行することができます。
- 注意：ここでの仮想マシンはVMwareやKVM等のOSを実行するために仮想マシンではなく、JVMなどの言語処理系の仮想マシンになります。
- シングルプロセッサ上では、カーネルスレッドとグリーンスレッドのどちらがよいパフォーマンスを発揮するかは一般的には明らかではありません。
- ネイティブスレッドは I/O や コンテキストスイッチの処理に関して、大きく上回る
- OSがスタックを作成するのではなく、ヒープから割り当てられます。これにより、並列スレッドが1桁以上増加する可能性があります
- 仮想スレッドのライフサイクルにOSが関与しなくなることで、スケーラビリティのボトルネックが解消されます

### カーネル空間
[メモ]
- 階層型に設計されたオペレーティングシステム (OS) の中核となる部分
- アプリケーションとハードウェアレベルでの実際のデータ処理との間の架け橋
- システムのリソースを管理し、ハードウェアとソフトウェアコンポーネントのやりとりを管理
- オペレーティングシステムの基本コンポーネントとして、カーネルはメモリ、CPU、入出力を中心としたハードウェアを抽象化し、ハードウェアとソフトウェアがやり取りできるようにする
- ユーザープログラムのための機能として、プロセスの抽象化、プロセス間通信、システムコールなどを提供する
- オペレーティングシステムのカーネルが存在する仮想メモリ領域である

### ユーザー空間 (アドレス空間)
[メモ]
- メモリアドレスが意味を成すコンテキストを定義したもの
- 一連のメモリアドレスによってアクセス可能なメモリ空間を意味する
- ユーザー空間に構築されているため、グリーンスレッドはネイティブスレッドより軽量
- スレッドの起床と同期化について、ネイティブスレッドの性能を上回る

アドレス空間の例：
*主記憶装置（物理メモリ）
*仮想メモリ
*I/O ポート空間
*IPアドレス

Macのアクティビティモニタで、使用しているスレッド、プロセスの数その割合(OS, ユーザー)を確認できる

![](Thread.png)

## Javaのスレッド

## JVMはOSのスレッドを使用
[メモ]
- 最初期のJVM実装では、実際にはプラットフォーム・スレッドを1つしか使わなかったので、この仕組みはグリーン・スレッドと呼ばれていました。
- Java 1.2とJava 1.3の時代（SunのSolaris OSの少し前）あたりで消滅しました。その代わりとして、主流のOSで実行される最近のバージョンのJavaでは、1つのJavaスレッドが厳密に1つのOSスレッドと対応するというルールが実装されています。
- Thread.start()を使うと、スレッドを作成するシステム・コール（Linuxのclone()など）が呼び出され、新しいOSスレッドが実際に作成されます。
- Java 1.0のときのマルチスレッドの主な要求は、ロジック進行によってGUIが止まらないようにする、たとえば処理中にプログレスバーがちゃんと表示できるようにするものだったのだけど、いまのマルチスレッドの主な要求は通信リクエストを複数同時にさばくことに変化してる。
- OpenJDKのProject Loomが仮想スレッドを追加実装しようとしている

## Futureパターン

[メモ]
- scala.concurrent.Futureは、scala.concurrent.ExecutionContextを介して複数のスレッドで作業をスケジューリングすることにより並列処理をサポートしている。
- 内部的にはJavaのRunnableに変換される
  - このRunnableをExecutionContextが良い感じにスレッドに割り当ててくれる
  - OSのスケジューラーにより均等に割り当てられ、実行されていく

## IO
## Future/IOのパフォーマンス
## まとめ