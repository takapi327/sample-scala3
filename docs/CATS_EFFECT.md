# Cats Effectに関して

Cats Effectは、マルチコアを効果的に使用し、リソースをリークさせないコードを簡単に書くことができるライブラリ

高度に並列化されたサービスのような複雑なアプリケーションの構築が、より生産的になる

## エッセンシャルエフェクトを使ってできること
- 副作用と効果の意味と役割を理解する
- 副作用をより安全な形でカプセル化する方法について理解します
- parMapNや他のコンビネータを使用して、エフェクトを並行して実行する
- 独立した作業を並列タスクに分割し、それらをキャンセルまたは結合する
- CPU バウンドの仕事とブロック化、I/O バウンドの仕事を分ける方法を学びます。
- scala.concurrent.Future のようなコールバックベースのコードを、より安全なエフェクトベースのインタフェースに統合する
- アプリケーションのためのリークプルーフのリソースを構築し、組み合わせることができます
- 並行処理やI/Oのような複数の効果を実行するコードをテストします

Cats Effect ライブラリの設計では、並列性，並行性などの概念を表現するために型クラスを使っている

Essential Effectsは、ファンクタ、アプリケーティブ、モナドといった関数型プログラミングの共通技術に基づいて構築されています

### Functors
ファンクタは、「内容」（または出力）を変えながら、その構造自体を変更することができるものという概念です。

「内容」（または出力）を変えるが、構造そのものは変えないというものです。

```scala
List(1, 2, 3).map(_ + 1) // List(2, 3, 4)
Option(1).map(_ + 1) // Some(2)
Future(1).map(_ + 1) // ...eventually Future(2)
```

型F[A]のある値に対するmapのシグネチャ（ここで、型FはList、Optionなど） は次のようになる。

```scala
def map[B](f: A => B): F[B]
```

### Applicatives

適用型ファンクタは、applicative とも呼ばれ、1つの構造だけでなく、複数の構造を変換できるファンクタのことです。この例では、まず1つの Option 値に map を適用し（これはファンクタです）、それを拡張して、値のタプルに作用する applicative mapN メソッドを示してみましょう

```scala

Option(1).map(_ + 1) // Some(2)
(Option(1), Option(2)).mapN(_ + _ + 1) // Some(4)
(Option(1), Option(2), Option(3)).mapN(_ + _ + _ + 1) // Some(7)
```

より一般的には、F[_]という名前のあるアプリケーティブ型に対して、 mapNを用いてF値のタプルを一つのF値に合成することができる。

```scala
def map[B](A => B): F[B]
def mapN[C]((A, B) => C): F[C]
def mapN[D]((A, B, C) => D): F[D]
... ...
def mapN[Z]((A, ...) => Z): F[Z]
```

### Monads

モナドとは、計算の順序を決める仕組みのことで、この計算はこの計算の後に行われます。大雑把に言えば、モナドは値F[A]に対してflatMapメソッドを提供する

```scala
def flatMap[B](f: A => F[B]): F[B]
```

あるモナドF[_]のflatMapを使って、計算の順序を決めることができる。

```scala
val fa: F[A] = ???
def next(a: A): F[B] = ???
val fb: F[B] = fa.flatMap(next)
```

ネストした flatMap 呼び出しは、2つ以上の計算を並べるときに読みづらくなるので、代わりに for-comprehension を使うことができます。これは、ネストした flatMap 呼び出しのための単なる構文上の糖分である。

```scala
val fa: F[A] = ???
def nextB(a: A): F[B] = ???
def nextC(b: B): F[C] = ???

val fc: F[C] =
  for
    a <- fa
    b <- nextB(a)
    c <- nextC(b)
  yield c
```
